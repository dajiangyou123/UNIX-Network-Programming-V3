#第 6 章  I/O复用：select和poll函数


###1. I/O复用概念
> 当内核一旦发现进程指定的一个或多个I/O条件就绪（也就是说输入已准备好被读取，或者描述符已能承接更多的输出），它就通知进程。这就是I/O复用,是由select和poll这两个函数支持的，还有较新的POSIX变种pselect。


###2. I/O复用技术典型使用的网络应用场合
>
* 当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用;     
* 一个客户同时处理多个套接字是可能的，不过比较少见;       
* 如果一个TCP服务器既要监听套接字，又要处理已连接套接字,一般就要使用I/O复用;      
* 如果一个服务器既要处理TCP，又要处理UDP，一般就要使用I/O复用;   
* 如果一个服务器要处理多个服务或者多个协议，一般就要使用I/O复用。


###3. I/O模型
>
* **阻塞式I/O**: 应用进程的系统调用开始直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回,即在这**整个过程中进程都是阻塞的**。**默认**情况下，所有套接字都是阻塞的。   
* **非阻塞式I/O**: 当数据报没有准备好时，**立即返回**一个错误,不阻塞进程，通过不断轮询的方法直到数据报准备好，然后发生**I/O阻塞**，直到数据报复制到应用进程的缓冲区为止。这种**轮询**的方法**耗费大量CPU时间**。    
* **I/O复用**: 进程调用select或者poll，且**阻塞**在这两个其中之一上，而**不是**阻塞在真正的I/O系统调用上。直到数据报套接字变为可读时，启动I/O系统调用，**进程I/O阻塞**，直到数据报复制到应用进程的缓冲区为止。(使用select需要**两个系统调用**)   
* **信号驱动式I/O**: 首先建立信号处理函数，建立完毕后**立即返回，不阻塞**。当数据报准备好读取时，内核为该进程产生一个SIGIO信号，然后调用信号处理函数，启动I/O系统调用，**进程I/O阻塞**，直到数据报复制到应用进程的缓冲区为止。这个模型的优势在于等待数据报到达期间进程**不被阻塞**，当然复制数据报到应用进程的缓冲区还是会发生I/O阻塞的。    
* **异步I/O**: 由POSIX规范定义。对于读取数据报的操作，调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。该系统调用**立即返回**，而且在等待I/O完成期间,进程不阻塞，即在数据复制到进程缓冲区期间也不会阻塞，这一点与**信号驱动式I/O不同**。   

>> 注：对于这五种I/O模型，**前四种**模型的主要区别**在于第一阶段**，而他们的**第二阶段**，即数据报复制到进程的缓冲区阶段，都是**一样**的。**最后异步I/O模型**与前四种模型不一样，这两个阶段都是处理完毕后才通知进程进行下一步操作，且整个过程应用进程**不发生I/O阻塞**。

---
>> 
* 同步I/O操作：I/O操作导致请求进程阻塞，直到I/O操作完成,比如上面的前四个模型，阻塞式I/O、非阻塞式I/O、I/O复用、信号驱动式I/O，这四个模型的第二阶段都产生I/O阻塞；    
* 异步I/O操作：I/O操作不导致请求进程操作,比如上面的异步I/O。



