#第 6 章  I/O复用：select和poll函数


###1. I/O复用概念
> 当内核一旦发现进程指定的一个或多个I/O条件就绪（也就是说输入已准备好被读取，或者描述符已能承接更多的输出），它就通知进程。这就是I/O复用,是由select和poll这两个函数支持的，还有较新的POSIX变种pselect。


###2. I/O复用技术典型使用的网络应用场合
>
* 当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用;     
* 一个客户同时处理多个套接字是可能的，不过比较少见;       
* 如果一个TCP服务器既要监听套接字，又要处理已连接套接字,一般就要使用I/O复用;      
* 如果一个服务器既要处理TCP，又要处理UDP，一般就要使用I/O复用;   
* 如果一个服务器要处理多个服务或者多个协议，一般就要使用I/O复用。


###3. I/O模型
>
* **阻塞式I/O**: 应用进程的系统调用开始直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回,即在这**整个过程中进程都是阻塞的**。**默认**情况下，所有套接字都是阻塞的。   
* **非阻塞式I/O**: 当数据报没有准备好时，**立即返回**一个错误,不阻塞进程，通过不断轮询的方法直到数据报准备好，然后发生**I/O阻塞**，直到数据报复制到应用进程的缓冲区为止。这种**轮询**的方法**耗费大量CPU时间**。    
* **I/O复用**: 进程调用select或者poll，且**阻塞**在这两个其中之一上，而**不是**阻塞在真正的I/O系统调用上。直到数据报套接字变为可读时，启动I/O系统调用，**进程I/O阻塞**，直到数据报复制到应用进程的缓冲区为止。(使用select需要**两个系统调用**)   
* **信号驱动式I/O**: 首先建立信号处理函数，建立完毕后**立即返回，不阻塞**。当数据报准备好读取时，内核为该进程产生一个SIGIO信号，然后调用信号处理函数，启动I/O系统调用，**进程I/O阻塞**，直到数据报复制到应用进程的缓冲区为止。这个模型的优势在于等待数据报到达期间进程**不被阻塞**，当然复制数据报到应用进程的缓冲区还是会发生I/O阻塞的。    
* **异步I/O**: 由POSIX规范定义。对于读取数据报的操作，调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。该系统调用**立即返回**，而且在等待I/O完成期间,进程不阻塞，即在数据复制到进程缓冲区期间也不会阻塞，这一点与**信号驱动式I/O不同**。   

>> 注：对于这五种I/O模型，**前四种**模型的主要区别**在于第一阶段**，而他们的**第二阶段**，即数据报复制到进程的缓冲区阶段，都是**一样**的。**最后异步I/O模型**与前四种模型不一样，这两个阶段都是处理完毕后才通知进程进行下一步操作，且整个过程应用进程**不发生I/O阻塞**。

---
>> 
* **同步I/O操作**：I/O操作导致请求进程阻塞，直到I/O操作完成,比如上面的**前四个模型**，**阻塞式I/O**、**非阻塞式I/O**、**I/O复用**、**信号驱动式I/O**，这四个模型的**第二阶段**都产生I/O阻塞；    
* **异步I/O操作**：I/O操作**不导致**请求进程阻塞,比如上面的**异步I/O**。


###4. select函数
```C
#include <sys/select.h>
#include <sys/time.h>

int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
		//作用：允许进程指示内核等待多个事件中的任何一个发生，并只在一个或多个事件发生或经历一段指定的时间后才唤醒它，多用于I/O复用（即I/O多路转接）；
		//返回：若成功，返回准备就绪的描述符数目；若超时，返回0；若出错，返回-1
		//注：函数的最后一个参数在linux-4.2.0-36的版本下是没有const修饰词的，本机为Ubuntu15.10即是如此。
```
> select中timeout参数有三种可能：     
* 设为**空指针NULL**，代表着永远等待下去，直到指定的描述符中有准备好的或者捕捉到一个信号才返回。  
* timeout中的值**都不为0**，代表着等待这段时间，直到指定的描述符中有准备好的、超时（返回0）、捕捉到一个信号这三种情况下才立即返回。  
* timeout中的值**都为0**，检查描述符后立即返回，这是使用轮询的方法，不阻塞进程。   


###5. select函数中的注意事项
> 
* fd_set数据类型每次使用前，都要通过**FD_ZERO()**来初始化，将描述符集置为**0**。通过**FD_SET()**来设置我们关心的描述符，其实就是将
fd_set中该描述符所在的位设为**1**(fd_set的实现一般都是将每个描述符用一位来表示，存在一个整数中，32位的则可以保存32个描述符的状态),
也可以通过调用**FD_CLR()**将一个描述符所在的位置为0，即不关心该描述符。当select成功返回时，将未准备就绪的描述符所在的位全置为0，即
每次返回后有些关心的描述符所在的位变成0，所以每次重新调用select函数都得**重新使用FD_ZERO()初始化**，在使用**FD_SET()**来设置我们所
关心的描述符。   
* 中间的三个参数readset,writeset和exceptset指定我们要让内核测试的读、写和异常这三个条件的描述符。目前支持的**异常条件**只有**两个***：   
(1) 某个套接字的带外数据的到达；   
(2) 某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息。   
* **maxfdp1**参数是待测试的**最大描述符加1**,即描述符**0**,**1**,**2**...一直到**maxfdp1 - 1**均将被测试(哪怕这些描述符中有的我们并**不**需要关心)，共**maxfdp1**个要测试的描述符。    
* 该函数的**返回值**是三个描述符集已就绪的总个数，同时如果有一个描述符**既**发生了**写**就绪，**又读**就绪，那么返回的应该数目应该**加2**，而不是**1**。   
* select中描述符**就绪条件**小结：    

|条件 | 可读吗 | 可写吗 | 异常吗 |
|:---:|:------:|:------:|:------:|
|有数据可读 | * | | |
|关闭连接的读一半 | * | | |
|给监听套接字接口准备好新连接 | * | | |
|有可用于写的空间 | | * | |
|关闭连接的写一半 | | * | |
|使用非阻塞式connect的套接字成功连接 或者 connect已经以失败告终 | | * | |
|待处理错误 | * | * | |
|TCP带外数据 | | | * |

* select函数的缺陷之一有**最大的描述符数限制**，\<sys/types.h\>中的**FD_SETSIZE**（APUE中说经常是1024,且定义在sys/select.h中）。


###6. shutdown函数
```C
#include <sys/socket.h>

int shutdown(int sockfd, int howto);
		//作用：可以执行读关闭，写关闭，也可以执行全关闭,与close不同。
		//返回：若成功则为0，若出错则为-1
```
> shutdown的执行效果由*howto*参数决定.    
* *howto*为**SHUT_RD**(一般为0)，关闭读的一端，此时接收缓冲区中的现有数据会丢失，且之后对端发来数据都会被确认之后，悄然**丢弃**，对端不知；   
* *howto*为**SHUT_WR**(一般为1)，关闭写的一端，对于TCP也被称为**半关闭**。此时发送缓冲区中的数据将被**发送掉**，并且后面加上一个**FIN**，而不是将缓冲区中的数据丢弃掉，同时对于当前套接字描述符的**引用次数**
并不要求一定为**0**，同时套接字**不能**再调用**写**函数。   
* **howto**为**SHUT_RDWR**(一般为2)，这与调用两次shutdown差不多:第一次调用**SHUT_RD**类型，第二次调用**SHUT_WR**类型。    





