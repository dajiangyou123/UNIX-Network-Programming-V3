#第 5 章  TCP客户/服务器程序示例


###1. 处理SIGCHLD信号

> 子进程退出后，内核会发送一个SIGCHLD信号给父进程，该信号的默认是忽略，那么子进程会成为**僵尸进程**并占用系统资源，如进程ID，终止状态以及资源利用信息等。所以我们应该通过*signal函数(sigaction函数更好)*设定信号处理函数去释放子进程占用的资源，比如在该处理函数中调用wait或waitpid函数等方法解决该问题。


###2. 处理被中断的系统调用

> *1*中虽然处理了SIGCHLD信号，但是父进程捕获该信号会导致**慢系统调用（accept）中断**，有些系统默认自动重启系统调用，有些系统不默认自动重启，所以可以通过**sigaction函数(signal函数不可以)**设定SA_RESTART来由内核自动重启中断。但是由于标准不一，有点系统**没有SA_RESTART标志**，我们可以通过判断错误码是否为EINTR,若是，则再次重新调用该系统中断。这种方法对于accept、read、write、select、open之类的函数来说是有用的，但是**对于connect不能重启**，必须调用select来等待连接完成，因为**TCP的三次握手还在继续进行**。


###3. wait和waitpid函数
```C
#include <sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);
		//作用：获得子进程的终止状态
		//返回：若成功返回子进程ID，若出错，则wait返回-1,waitpid可能是0或-1
```

> wait会**一直阻塞**,直到任一子进程终止。如果当前没有任何子进程在运行，则会出错返回-1.   
waitpid可以选择等待哪个子进程返回，也可以与wait一样，等待任一子进程返回(把pid设为-1即可),同时可以使用options参数指定附加选项。最常见的是**设为WNOHANG**，告知内核当前没有终止的子进程时不要阻塞，直接返回，此时返回值是**0**。


###4. 对于多进程服务器遇到的问题
>
* 当fork一个子进程时，必须捕获SIGCHLD信号；
* 当捕获信号时，必须处理被中断的系统调用；
* SIGCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵死进程(因为信号一般是**不排队**的，所以信号的捕获往往同时只能捕获两次，即调用两次信号处理函数，对于接收子进程的终止状态这种情况可以通过在信号处理函数中**使用waitpid非阻塞循环获取**来处理)。


###5. accept返回前连接中止
> TCP**已经完成**了三次握手，accept正准备返回**前**，客户发送了一个**RST**到达过来，此时accpet也会显示出错，
但这不是服务器的原因，服务器应该重启accept而不是关闭退出。对于这个**非致命的错误**，取其errno值时，各个系统**实现不一**，
甚至源自Berkeley的实现对其的处理完全在内核中处理，服务器进程根本看不到（内核直接将其在已连接队列中将其删除）。
大多数**SVR4**会返回一个*EPROTO*（"protocol error",协议错误）errno值，而**POSIX**则返回一个*ECONNABORTED*("software caused connection abort",软件引起的连接中止).
POSIX做出修改的**理由**是：流子系统（steams subsystem）中发生某些**致命**的协议相关事件时，也会返回EPROTO。故在POSIX中通过*检查错误代码是否是ECONNABORTED*来决定是否重启accept调用。




